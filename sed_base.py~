import spider_analysis as sa
import fg_models
import numpy as np
import pickle
import sed_lib as sl
import time
import subprocess


default_names = { 23: 'map_wmap_k',
                  30: 'map_wmap_ka',
                  40: 'map_wmap_q',
                  60: 'map_wmap_v',
                  90: 'map_wmap_w',
                  94.5: 'map_spider_90',
                  94.51: 'map_spider_90_0', 94.52: 'map_spider_90_1', 94.53: 'map_spider_90_2', 94.54: 'map_spider_90_3',
                  101.3: 'map_planck_100',
                  141.9: 'map_planck_143',
                  150.5: 'map_spider_150a',
                  150.51: 'map_spider_150a_0',150.52: 'map_spider_150a_1',150.53: 'map_spider_150a_2',150.54: 'map_spider_150a_3',
                  220.6: 'map_planck_217',
                  359.7: 'map_planck_353' }

default_noise = { 23: 'map_23_{}',
                  30: 'map_30_{}',
                  40: 'map_40_{}',
                  60: 'map_60_{}',
                  90: 'map_90_{}',
                  94.5: 'map_94_{}',
                  94.51: 'map_94_{}_0', 94.52: 'map_94_{}_1', 94.53: 'map_94_{}_2', 94.54: 'map_94_{}_3',
                  101.3: 'map_100_{}',
                  141.9: 'map_143_{}',
                  150.5: 'map_150_{}',
                  150.51: 'map_150_{}_0', 150.52: 'map_150_{}_1', 150.53: 'map_150_{}_2', 150.54: 'map_150_{}_3',
                  220.6: 'map_217_{}',
                  359.7: 'map_353_{}' }


default_suffixes = ('_hm1', '_hm2')


class SED(object):
    def __init__(self, 
                 map_dir = '/projects/WCJONES/spider/SED_leakage_subtract/',
                 map_dict = default_names,
                 auto_suffixes = default_suffixes,
                 noise_dict = default_noise,
                 spec_file = '/projects/WCJONES/spider/jvlist/specs/SED_leakage_subtract.p', 
                 spec_err = '/projects/WCJONES/spider/jvlist/specs/SED_xflike_model_sims.p', 
                 post_dir = '/scratch/gpfs/jvlist/posteriors_leakage_subtract/',
                 misc_dir = '/projects/WCJONES/spider/jvlist/sed_misc/'
                 do_sim = False, 
                 do_cxd = True, 
                 fs_to_do = None
                 sed_model = 'dustxcmb', 
                 mask = np.logical_and(sa.map.standard_point_source_mask(), sa.map.latlon_mask()),
                 ells = [20.0, 45.0, 70.0, 95.0, 120.0, 145.0, 170.0]
                 pols = ['EE', 'BB']
                 recompute = None,
                 slurm_opts = {'mem':1, 'nodes':1, 'ppn':1, 'wallt':24, 'scheduler':'slurm', 
                               'queue':'spider', 'nice':100)
                 logfile = './logfile'
             ):
        self.map_dir = map_dir
        self.map_dict = map_dir
        self.auto_suffixes = auto_suffixes
        self.noise_dict = noise_dict
        self.spec_file = spec_file
        self.spec_err = spec_err
        self.post_dir = post_dir
        self.misc_dir = misc_dir
        self.do_sim = do_sim
        self.do_cxd = do_cxd
        self.sed_model = sed_model
        self.mask = mask
        self.ells = ells
        self.pols = pols
        self.recompute = recompute
        self.slurm_opts = slurm_opts
        self.logfile = logfile

        if fs_to_do is None:
            self.fs_to_do = [(f1*f2)**0.5 for f1 in map_dict.keys() for f2 in map_dict.keys()]
        else:
            self.fs_to_do = fs_to_do

        fg_models.get_model(model)


    def logm(self, s):
        with open(self.logfile, 'a') as lf:
            lf.write(s)
        return True


    def get_spec(self):

        fs = self.fs_to_do
        do_recompute = recompute in ['spectra']
        if os.path.exists(self.spec_file) and not do_recompute:
            with open(self.spec_file, 'r') as pfile: 
                return_spec = pickle.load(pfile)

        else:
            for i in range(len(fs)):
                self.logm(str(fs)+' x others')
                for j in range(i, i+len(fs[i:])):
                    ins_str = ''
                    
                    fname1, ext1 = fdict[fs[i]]
                    fname2, ext2 = fdict[fs[j]]
                    
                    mfile1 = mapdir+fname1
                    mfile2 = mapdir+fname2
                    
                    if bool(ext1) != bool(ext2):
                        pass
                    elif bool(ext1) and bool(ext2) and fname1 != fname2:
                        pass
                    elif bool(ext1) and ext1 == ext2:
                        pass
                    else:
                        if fname1 == fname2:
                            ext1 += auto_suffixes[0]
                            ext2 += auto_suffixes[1]

                        ellb, clsb, clse, freq = cross_maps(mfile1, mfile2, fs[i], fs[j], ext1, ext2)
                        ellb = [20.,45.,70.,95.,120.,145.,170.5]
                        specs[freq] = [ellb, clsb, clse]
                        
                        freq_pairs[freq] = (fs[i], fs[j])
                        fl_pairs[freq] = (flmap(fs[i]), flmap(fs[j]))

            if spec_err is not None:
                with open(self.spec_err, 'r') as pfile:
                    spec_err = pickle.load(pfile)

            for k in specs.keys():
                specs[k] = [specs[k][0], specs[k][1], specs_err[k][2]]

            return_spec = specs
        
        return return_spec


    def get_posteriors(self):
        
        do_recompute = recompute in ['spectra', 'posteriors']
        ep = ['dustxcmb_correlation'] if self.do_cxd else []
        
        if not do_recompute:
            try:
                return_params = get_data(do_sim, custom_dir=self.post_dir, extra_params=ep, ells_to_do=map(str, self.ells))
            except IOError:
                self.logm('No posterior files found in {}; computing posteriors.')

                make_posteriors(self)
                return_params = get_data(do_sim, custom_dir=self.post_dir, extra_params=ep, ells_to_do=map(str, self.ells))

        else:
            make_posteriors(self)
            return_params = get_data(do_sim, custom_dir=self.post_dir, extra_params=ep, ells_to_do=map(str, self.ells))

        return return_params





def make_posteriors(sed):
    ells = sed.ells
    pols = sed.pols
    do_sim = sed.do_sim
    model = sed.model
    spec_file = sed.spec_file
    post_dir = sed.post_dir
    sopts = sed.sopts

    for ell in ells:
        for pol in pols:
            sopts['name'] = name='sedfit_'+str(ell)+'_'+str(pol)
            sopts['output'] = './slurm/output_log_sed_{}_{}'.format(ell, pol)
            sopts['error'] = './slurm/error_log_sed_{}_{}'.format(ell, pol)
            
            sa.batch.qsub('python ./sed_fit.py "{}" "{}" "{}" "{}"'.format(ell, pol. do_sim, model), name='sedfit_'+str(ell)+'_'+str(pol), **sopts)
            sed.logm('Submitted sedfit_'+str(ell)+'_'+str(pol))
               
    #Watch slurm, don't proceed until all fit jobs are done
    while int(subprocess.check_output('squeue | grep sedfit | wc -l', shell=True)) > 0:
        time.sleep(60)

    return True
